import{j as e}from"./index-Bmr0gcqO.js";import{S as s}from"./styled-Bj7slSHo.js";const t=()=>e.jsxs(s.Page,{children:[e.jsx(s.Title,{children:"Performance Gotchas — Identity Traps"}),e.jsx(s.Subtitle,{children:"Simple rules to avoid extra re-renders and accidental work."}),e.jsxs(s.Section,{children:[e.jsx("h3",{children:"In one line"}),e.jsxs("p",{children:["Select the smallest slice, avoid returning fresh objects/arrays from selectors, and use ",e.jsx("code",{children:"shallow"})," when you must return a collection."]})]}),e.jsxs(s.Section,{children:[e.jsx("h3",{children:"Biggest culprits I watch for"}),e.jsxs("ul",{children:[e.jsxs("li",{children:["Selecting the ",e.jsx("b",{children:"entire store"})," in a component."]}),e.jsxs("li",{children:["Selectors that return a ",e.jsx("b",{children:"new object/array"})," every render."]}),e.jsxs("li",{children:["Heavy computations done ",e.jsx("b",{children:"inside"})," the selector."]}),e.jsxs("li",{children:["Updating nested objects without creating a ",e.jsx("b",{children:"new reference"}),"."]}),e.jsxs("li",{children:["Multiple ",e.jsx("code",{children:"set()"})," calls where one batched call would do."]})]})]}),e.jsxs(s.Section,{children:[e.jsx("h3",{children:"Over-selecting the store"}),e.jsx("pre",{className:"bad",children:`// ❌ causes re-render whenever *anything* in the store changes
const all = useApp((s) => s);`}),e.jsx("pre",{className:"good",children:`// ✅ subscribe to just what this component needs
const user = useApp((s) => s.auth.user);
const mode = useApp((s) => s.theme.mode);`})]}),e.jsxs(s.Section,{children:[e.jsx("h3",{children:"Returning fresh objects/arrays from the selector"}),e.jsx("pre",{className:"bad",children:`// ❌ new object each time → re-renders even if values are same
const view = useCart((s) => ({ items: s.items, total: s.total }));`}),e.jsx("pre",{className:"good",children:`// ✅ tuple + shallow (fast)
import { shallow } from 'zustand/shallow';
const [items, total] = useCart((s) => [s.items, s.total], shallow);

// ✅ object + shallow (more readable for many fields)
const view = useCart((s) => ({ items: s.items, total: s.total }), shallow);`})]}),e.jsxs(s.Section,{children:[e.jsx("h3",{children:"Heavy work inside the selector"}),e.jsx("pre",{className:"bad",children:`// ❌ selector runs on every store change; creates a new array each time
const visible = useTodos((s) => s.items.filter(t => !t.done));`}),e.jsx("pre",{className:"good",children:`// ✅ select inputs; compute with useMemo
const items = useTodos((s) => s.items);
const visible = React.useMemo(
  () => items.filter(t => !t.done),
  [items]
);`})]}),e.jsxs(s.Section,{children:[e.jsx("h3",{children:"Nested updates must create new references"}),e.jsx("pre",{className:"bad",children:`// ❌ mutates nested object; selectors reading user won't see a new reference
set((s) => { s.user.name = 'Ashish'; return s; }); // (also breaks immutability assumptions)`}),e.jsx("pre",{className:"good",children:`// ✅ create a new object for changed branch
set((s) => ({ user: { ...s.user, name: 'Ashish' } }), false, 'user/rename');`}),e.jsxs("p",{children:["If nested updates are frequent, consider the ",e.jsx("i",{children:"immer"})," middleware later; the idea stays the same: always produce a new reference for the changed branch."]})]}),e.jsxs(s.Section,{children:[e.jsx("h3",{children:"Batch related updates"}),e.jsx("pre",{className:"bad",children:`// ❌ two separate updates → two chances to re-render
set({ loading: true }, false, 'fetch/start');
set({ loading: false, data }, false, 'fetch/success');`}),e.jsx("pre",{className:"good",children:`// ✅ group related fields in one set()
set({ loading: false, data, error: null }, false, 'fetch/success');`})]}),e.jsxs(s.Section,{children:[e.jsx("h3",{children:"Selecting functions vs using actions directly"}),e.jsx("pre",{className:"bad",children:`// ❌ selector returns an inline function each time (new identity)
const doThing = useApp(() => (x) => console.log(x));`}),e.jsx("pre",{className:"good",children:`// ✅ read stable action references from the store
const addToCart = useApp((s) => s.addToCart);`}),e.jsx("p",{children:"Actions you define in the store are stable across renders; returning new inline functions from the selector creates new identities."})]}),e.jsxs(s.Section,{children:[e.jsx("h3",{children:"Deriving more than the component needs"}),e.jsx("pre",{className:"bad",children:`// ❌ selecting a big object when only count is needed
const view = useCounter((s) => ({ count: s.count, disabled: s.count > 10 }), shallow);`}),e.jsx("pre",{className:"good",children:`// ✅ keep it tiny
const count = useCounter((s) => s.count);`})]}),e.jsxs(s.Section,{children:[e.jsx("h3",{children:"How I debug renders quickly"}),e.jsxs("ul",{children:[e.jsx("li",{children:"Enable “Highlight updates” in React DevTools."}),e.jsxs("li",{children:["Use the devtools middleware and name actions: ",e.jsx("code",{children:"slice/action"}),"."]}),e.jsx("li",{children:"Temporarily log re-renders in a component to spot noisy selectors."})]}),e.jsx("pre",{className:"note",children:`// quick re-render counter
const renderCount = React.useRef(0);
React.useEffect(() => { renderCount.current += 1; console.log('renders:', renderCount.current); });`})]}),e.jsxs(s.Section,{children:[e.jsx("h3",{children:"Checklist"}),e.jsxs("ul",{children:[e.jsxs("li",{children:["Smallest slice possible; avoid ",e.jsx("code",{children:"(s) => s"})," in components."]}),e.jsxs("li",{children:["Return tuple/object + ",e.jsx("code",{children:"shallow"})," when selecting multiple values."]}),e.jsxs("li",{children:["Do heavy work in ",e.jsx("code",{children:"useMemo"})," or a selector helper, not inline."]}),e.jsx("li",{children:"Create new references for changed nested branches."}),e.jsxs("li",{children:["Batch related updates in a single ",e.jsx("code",{children:"set()"}),"."]})]})]})]});export{t as default};
